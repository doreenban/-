## 中兴

### 收集的

自己做的项目和参加的活动

#### 技术

1. tcp/udp的区别

   tcp面向连接的传输，提供可靠交付，面向字节流，适合对效率要求较低对安全性要求较高的场景；

   udp尽最大可能交付，面向报文，即时通信，如在线视频，语音通话场景

2. tcp拥塞控制机制

   1. 慢开始+拥塞避免
   2. 快恢复+快重传

3. access连接数据库的两种方式，区别

   access是Microsoft的一个非常小型的数据库，mysql是oracle支持的开源项目。access数据库的两种连接方式：

   1. 通过JDBC-ODBC方式直接连接

      1. 建立ODBC数据源；

      2. 找到access数据库的驱动程序并配置数据源；

      3. 写获取连接的代码

         ```Java
         //方便记忆连接的URL代码
         Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
         String url="jdbc:odbc:JDBC-ODBC";
         Connection con=DriverManager.getCOnnection(url);
         ```

   2. 通过连接数据库所在的绝对路径方式连接

      ```java
      //不用配置数据源，代码稍多
      Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
      String url = "jdbc:odbc:driver={Microsoft Access Driver (*.mdb)};DBQ="+"e://student.mdb ";
      Connection con = DriverManager.getConnection(url);
      ```

4. tcp的三次握手和四次挥手，以及time_wait

   三次握手是为了防止失效的连接请求到达服务器，使服务器错误打开连接

   四次挥手是因为客户端发送连接释放报文后进入close-wait状态，但此时服务端还在发送未传送完毕的数据，所以服务端在发送完毕数据后，还会发送一个连接释放报文。

   客户端确保自己发送的最后一个确认报文能送达，避免服务端超时未收到重新发送确认；让本连接持续时间内所产生的所有报文都从网络中消失，防止新连接中有旧报文。

5. 重载和重写

   都是Java多态性的体现，重写是子类对父类方法的重新实现，重载是根据形参和数据类型的不同，调用名字相同的方法。

6. 字符串逆序（手写代码）

7. 介绍面向对象

   面向对象有<u>**三大特性**</u>，**五大基本原则**：封装，继承，多态+单一职责原则，开放封闭原则，里氏替换原则，依赖倒置原则，接口分离原则。

   封装：隐藏对象的实现细节，仅对外提供公共访问方式

   继承：子类继承父类，实现代码复用，是多态的前提

   多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，提高了程序的拓展性。

   单一职责原则：类的功能要单一

   开放封闭原则：一个模块对于拓展是开放的，对于修改是封闭的

   里氏替换原则：子类能够替换父类出现在父类能够出现的任何地方

   依赖倒置原则：应用程序依赖于抽象，实现的细节依赖于抽象，降低了客户程序于实现细节的耦合度

   接口分离原则：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。如手机拥有打电话，玩游戏，看视频功能，将功能拆分成不同接口。

8. 软件设计原则

   1. 单一职责原则
   2. 开放封闭
   3. 接口分离
   4. 里氏替换原则
   5. 依赖倒置原则
   6. 合成聚合复用原则：在一个新的对象里使用一些已有的对象使其成为新对象的一部分，达到复用已有功能的目的(尽量减少继承)
   7. 迪米特法则(最少知识原则)：一个对象应当对其他对象有尽可能少的了解

9. 常用的数据结构，用途，复杂度

   |                   |                                                              |                                              |
   | ----------------- | ------------------------------------------------------------ | -------------------------------------------- |
   | 数组              | 内存连续，所有数组类型相同，数组大小固定，线性结构           | 支持随机访问，插入删除效率低                 |
   | 链表              | 内存不连续，线性结构                                         | 不支持随机访问，插入删除效率高               |
   | 栈和队列          | 先进后出/先进先出，只能一端插入删除元素，线性结构            |                                              |
   | 树-二叉树         | 每个节点最多两个子树                                         |                                              |
   | 树-满二叉树       | 深度为k，节点数为2^k-1                                       |                                              |
   | 树-完全二叉树     | 只有最后一层不满                                             |                                              |
   | 树-二叉搜索树     | 左子树节点值都小于根节点，右子树节点值都大于根节点           | 可能退化成链表                               |
   | 树-平衡二叉树     | 左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差不超过1 | 解决二叉搜索树退化成链表                     |
   | 树-平衡二叉查找树 | 平衡+查找                                                    | 解决二叉搜索树退化成链表                     |
   | 树-红黑树         |                                                              | 解决平衡二叉查找树需要插入和删除多次才能平衡 |
   | B树               |                                                              |                                              |
   | B+树              |                                                              |                                              |
   | 图                |                                                              |                                              |

10. 集合

    |            |      |            |                                    |      |      |
    | :--------- | ---- | ---------- | ---------------------------------- | ---- | ---- |
    | Collection | List | ArrayList  | 数组                               |      |      |
    |            |      | LinkedList | 双向链表                           |      |      |
    |            |      | Vector     | synchronized保证线程安全           |      |      |
    |            | Set  | HashSet    | hashcode和equals方法保证元素不重复 |      |      |
    |            |      | TreeSet    | 有序不重复                         |      |      |
    | Map        |      | HashMap    | 数组+链表                          |      |      |
    |            |      | TreeMap    | 二叉搜索树/红黑树                  |      |      |

11. Linux系统哪几部分组成

    内核，shell，文件系统和应用程序

12. OSI七层模型？TCP哪一层

    物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

13. 设计模式

14. 对多线程的了解，创建线程，锁，无锁编程

15. SSM框架各个层讲一下，各个层之间怎么调用，怎么返回。前端到后台，后台到数据库，查到数据之后到后台再返回到前端的整个流程

16. Spring面向切面编程做过吗? springMVC和mybatis源码看过吗？

17. 怎么防止sql注入？按月模糊查询怎么查询？sql语句怎么写？降序排序sql语句怎么写？

18. 广播和单播？局域网和广域网？同一局域网下网段要相同吗？如果不是路由器，是交换机网段要相同吗？

19. 双工通信和单工通信？

20. Linux一些简单的命令

21. Redis怎么解决双写一致性问题
    两种策略，策略1：先删除缓存，再更新数据库 策略2：先更新数据库，再删除缓存

22. mysql两种搜索引擎的主要区别：锁 事务 索引

23. 索引类别以及底层实现机制，B-Tree 索引在两种引擎中的区别

    普通索引，主键索引，唯一索引，聚簇索引，覆盖索引

24. InnoDB行级锁：共享锁，排他锁，间隙锁

25. jvm调优经验，怎么指定垃圾回收算法？

    JVM调优主要是解决两个问题，Full GC的次数与单次Full GC的时间。通过JDK提供的内存查看国际Jconsole与JvisualVM。

    （1） 旧生代的内存不足

    （2） Parmanet Generation空间不足

    （3） System.gc()被显示调用

    （4） 调优主要是通过控制堆内存各个部分的比例和GC策略来实现的。

    具体调试过程。

26. 垃圾回收机制

27. 学生表里如何查找成绩第二名的学生

28. 对线程安全的了解，Java里哪些类是保障线程安全的

29. 介绍下字符串

30. 介绍下事务

31. mysql存储引擎介绍，不同

32. Springboot介绍，配置文件是什么

33. Spring核心

34. AES DES

35. tcp/ip如何传输数据(三握四挥)

36. 重写hashcode和equals函数

    ```java
    //String中的hashCode函数 对每一个元素计算hashcode然后相加
    //s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
    public int hashCode(){
    	int h=hash;
    	if(h==0&&value.length>0){
    		char val[]=value;
    		for(int i=0;i<value.length;i++){
    			h=31*h+val[i];
    		}
    		hash=h;
    	}
    	return h;
    }
    //重写hashcode，对需要的字段计算hashcode，然后相加
    @Override
    public int hashCode() {
      int result = name.hashCode();
      result = 17 * result + sex.hashCode();
      result = 17 * result + age.hashCode();
      return result;
    }
    //重写equals方法
    
    ```

    

#### 项目

语言？

实现具体细节

涉及算法

实习做的具体工作，为什么这么做

Java会到什么程度 具体说明一下？

实习或做项目的过程中和周边人的交流与沟通

中兴加班了解吗 能接受吗

#### 综合面

哪的人

证书带上

身份证

简单说一下项目

为什么选择南京







