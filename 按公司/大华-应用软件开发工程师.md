## 收集的
### 一面
- hashMap  
数组+链表的结构，使用key-value的形式存储数据，新建hashmap默认大小为16，扩容每次是2倍。常用方法是get和put，在jdk1.7中采用头插法插入数据，允许key为null，为空的数据被放到数组下标为0的桶中。
- 自己实现了一个对象，重载hashcode方法，还需不需要重载其他方法    
equals
- 在多线程环境中，如何保证使用的对象是线程安全的  
加锁，如synchronized，reentrantlock
- 虚拟机的堆内存分为几个区  
方法区，堆，程序计数器，虚拟机栈，本地方法栈  
eden，from survivor，to survivor？
- 堆里面主要干什么  
内存分配，内存回收  
- 堆里面能不能细分到哪些区
- 不同的区使用的算法都是一样的吗
- Spring和Spring boot的区别  
  1. Spring  
  为开发Spring应用程序提供了全面的基础架构支持，可以缩短应用程序的开发时间
  2. Springboot  
  Springboot是Spring框架的扩展，与Spring的目标一致，但消除了对配置文件的配置
- Springboot是如何简化哪些配置，具体是怎么实现的  
和SpringbootApplication 注解相结合，在main中通过调用run方法来加载 监控任务执行时间，创建应用上下文，程序运行参数等相关配置
- http请求  
htto1.0定义了三种请求方法：get，post，head  
http1.1新增了六种请求方法：options，put，patch，delete，trace，connect  
get：请求指定的页面信息，并返回实体主体  
head：类似于get请求，返回的响应中没有具体的内容，用于获取报头  
post：向指定资源提交数据进行处理请求  
put：从客户端向服务器传送的数据取代指定的文档的内容  
delete：请求服务器删除指定的页面  
connect：http1.1协议中预留给能够将连接改为管道方式的代理服务器  
options：允许客户端查看服务器的性能  
trace：回显服务器接收到的请求，主要用于测试或诊断  
patch：是对put方法的补充，用来对已知资源进行局部更新  
- 实现文件上传，请求头是什么  
post
- ConcurrenthashMap的理解  
ConcurrentHashMap实现了ConcurrentMap接口，内部的数据结构有一个分段锁，segment，分段锁保证了线程的安全性，继承了ReentrantLock类，而ReentrantLock类实现了Lock接口，
其中的final Sync类型的变量继承了AbstractQueuedSynchronizer类，并且在ReentrantLock类中实现了一个NonFairSync和FairSync类，
在类中实现了tryAcquire方法。
- 线程池的理解  
线程池就是事先将线程放到一个容器中，当使用线程的时候不需要new，使用完毕不需要销毁  
好处：减少了创建/销毁线程的开销；增加了响应速度；便于对线程进行管理  
创建线程池的方式 ：  
  1. 创建固定大小的：可以在已知并发压力的情况下，对线程数做限制
  2. 创建可缓存的线程池：可无限扩大，适合处理任务耗时较小的场景
  3. 创建单一线程的线程池：保证所有的任务按照先入先出的顺序执行
  4. 可调度的线程池：适合周期任务的场景
- 对mvc模型的理解  
  1. 模型层：业务逻辑层，是整个应用程序的核心，接受视图层请求的数据并进行处理，将处理结果返回给视图层
  2. 视图层：与用户交互的洁面
  3. 控制层：接受用户的请求，并根据请求决定调用哪个视图层和模型层来处理请求
  优点：降低代码之间的耦合性，提高可重用性
- 对Spring框架的理解
- 对bio，nio，aio的理解  
BIO同步阻塞：
NIO同步非阻塞：
AIO异步非阻塞：
- 对io，nio的理解  
最主要的区别是数据打包和数据传输的方式，io以面向字节的方式处理，一个字节一个字节的处理会很慢，nio以面向缓冲区的方式处理数据比较快。
nio建立连接后开始读写，会阻塞；而nio将读写拆分为准备读写和真正读写，准备阶段非阻塞，但真正读写的时候还是会阻塞。
- 数据库中左连接，右连接，内连接的区别  
左连接where对右表起作用，右连接where对左表起作用，内连接显示两表共有的记录
- 在tcp/ip五层传输协议中，数据传输的方式还有给数据加头加的是什么头  
在向下的过程中，需要添加下层协议所需要的首部和尾部，而在向上的过程中需要不断拆开首部和尾部  
用户数据在应用层加application头；在传输层加tcp报头封装成TCP段；网络层加IP报头封装成IP数据报；数据链路层封装成帧加以太网首部；
[数据的封装过程](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=0a663605dc09b3deffb2ec3aadd607e4/b151f8198618367a869ceeb023738bd4b31ce542.jpg)
- 拥塞控制的算法 [TCP连接拥塞控制四种方法总计](https://blog.csdn.net/qq_26896213/article/details/84594060)  
慢开始与拥塞避免：慢开始是指不要一开始就发送大量网络数据，拥塞避免是由小到大增加拥塞窗口的大小；  
快重传与快回复：要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。
- 流量控制  
流量控制为了控制发送方发送速率，保证接收方来得及接收。拥塞控制是为了降低整个网络的拥塞程度
- 良好的编程习惯是指  
  1. 变量的命名，编程的格式，清晰的注释
  2. 全局变量少
  3. 用的多的参数可以做成一个配置文件
  4. 权限限定符
  5. 及时释放不使用的连接，监听器以免造成内存泄漏

### 二面
- 数据库优化操作  
  1. 查询上的优化：使用explain语句分析查询；减少请求的数据量；减少扫描行数(使用索引)；切分查询  
  2. 结构上的优化：使用联合索引；使用前缀索引(BLOB，TEXT，VARCHAR类型)；对区分度大的字段构建索引；区分度强的字段放在前面；  
- 索引失效的情况
  1. 一些关键字：通配符以%开头，is null，is not null，or；
  2. 对索引字段使用函数，表达式；
  3. 索引中出现隐式类型转换
  4. 对两列都建了单独索引；
  5. 联合索引没有遵循最左匹配原则；
  6. mysql估计全表扫描比索引快
- 项目中使用了redis，如何操作的，为什么要用redis
- 怎么解决双写一致性？
- 项目中如何使用多线程，举个例子
- 线程安全的容器有哪些
  1. 同步类，使用了synchronized：Vector，HashTable
  2. 并发容器：ConcurrentHashMap
  3. 队列：ConcurrentLinkedQueue
- Java虚拟机里面的垃圾回收机制有哪些
- 项目中有没有看过进程中有哪些线程，jvm内存的情况
- 场景题
- 操作系统进程，线程，PV操作伪代码
- Spring注解方面的理解
- tomcat内存溢出的解决方法
- 平时如何学习Java
- 数据库基础 (触发器，视图，存储过程)
- 如何优化数据库
- 个人优点

### HR面
- 为什么选择我们公司  中国三大安防企业
- 工作的意向城市
- 现在进度最快的公司
- 拿到几家offer，是否谈过薪资
- 实习了多久，介绍一下印象最深刻的项目
- 你了解的互联网薪资一般多少
- 你的兴趣爱好
